diff --git a/CMakeLists.txt b/CMakeLists.txt
index dc4b770..f8eac22 100755
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -88,7 +88,7 @@ find_package(Wayland REQUIRED COMPONENTS Client)
 find_package(PlasmaWaylandProtocols REQUIRED)
 find_package(LayerShellQt REQUIRED)
 find_package(KPipeWire)
-find_package(OpenCV REQUIRED core imgproc)
+#find_package(OpenCV REQUIRED core imgproc)
 
 set_package_properties(KPipeWire PROPERTIES DESCRIPTION
     "Used to record pipewire streams into a file"
diff --git a/src/Gui/Annotations/EffectUtils.cpp b/src/Gui/Annotations/EffectUtils.cpp
index 7d505a5..a61e4b2 100755
--- a/src/Gui/Annotations/EffectUtils.cpp
+++ b/src/Gui/Annotations/EffectUtils.cpp
@@ -5,7 +5,7 @@
  */
 
 #include "EffectUtils.h"
-#include "QtCV.h"
+//#include "QtCV.h"
 
 #include <QDebug>
 #include <QPainter>
@@ -147,6 +147,7 @@ QImage shapeShadow(const Traits::OptTuple &traits, qreal devicePixelRatio)
         p.drawText(geometryTrait->path.boundingRect(), textTrait->textFlags(), textTrait->text());
     }
     p.end();
+    /*
     auto mat = QtCV::qImageToMat(shadow);
     const qreal sigma = Traits::Shadow::radius * devicePixelRatio;
     const int ksize = QtCV::sigmaToKSize(sigma);
@@ -155,5 +156,6 @@ QImage shapeShadow(const Traits::OptTuple &traits, qreal devicePixelRatio)
     // We only want black shadows with opacity, so we only need black and 8 bits of alpha.
     // If we don't do this, color emojis won't have black semi-transparent shadows.
     shadow.convertTo(QImage::Format_Alpha8);
+    */
     return shadow;
 }
diff --git a/src/Gui/Annotations/Traits.cpp b/src/Gui/Annotations/Traits.cpp
index 396d341..7049fe6 100755
--- a/src/Gui/Annotations/Traits.cpp
+++ b/src/Gui/Annotations/Traits.cpp
@@ -5,7 +5,7 @@
 
 #include "Traits.h"
 #include "Geometry.h"
-#include "QtCV.h"
+//#include "QtCV.h"
 #include "settings.h"
 #include <QLocale>
 #include <QUuid>
@@ -81,6 +81,7 @@ QImage Traits::ImageEffects::Blur::image(const std::function<QImage()> &getImage
          || m_backingStoreCache.devicePixelRatio() != dpr //
          || m_backingStoreCache.text(strengthKey).toDouble() != m_strength)
         && getImage) {
+/*
         m_backingStoreCache = getImage();
         if (m_backingStoreCache.isNull()) {
             return m_backingStoreCache;
@@ -99,6 +100,7 @@ QImage Traits::ImageEffects::Blur::image(const std::function<QImage()> &getImage
         QtCV::stackOrGaussianBlurCompatibility(mat, mat, {}, sigma, sigma);
         m_backingStoreCache.setDevicePixelRatio(dpr);
         m_backingStoreCache.setText(strengthKey, strengthString(m_strength));
+*/
     }
     QRect copyRect = G::rectScaled(rect, m_backingStoreCache.devicePixelRatio()).toAlignedRect();
     if (copyRect.size() != m_backingStoreCache.size()) {
diff --git a/src/Platforms/ImagePlatformKWin.cpp b/src/Platforms/ImagePlatformKWin.cpp
index 4105aae..6f94a71 100755
--- a/src/Platforms/ImagePlatformKWin.cpp
+++ b/src/Platforms/ImagePlatformKWin.cpp
@@ -7,7 +7,7 @@
 #include "ImagePlatformKWin.h"
 #include "ExportManager.h"
 #include "Geometry.h"
-#include "QtCV.h"
+//#include "QtCV.h"
 #include "DebugUtils.h"
 #include "ImageMetaData.h"
 
@@ -107,6 +107,7 @@ QImage combinedImage(const QList<QImage> &images)
     // Not sure what to do if we end up having different formats for different screens.
     QImage finalImage{imageRect.size().toSize() * finalDpr, finalFormat};
     finalImage.fill(Qt::transparent);
+    /*
     auto mainMat = QtCV::qImageToMat(finalImage);
     for (auto &image : images) {
         // Region Of Interest to put the image in the main image.
@@ -126,6 +127,7 @@ QImage combinedImage(const QList<QImage> &images)
         // Will just copy if there's no difference in size
         cv::resize(mat, mainMat(rect), rect.size(), 0, 0, interpolation);
     }
+    */
     finalImage.setDevicePixelRatio(finalDpr);
     ImageMetaData::setSubGeometryList(finalImage, geometryList);
     return finalImage;
